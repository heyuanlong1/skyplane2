// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class regReq;
class regResp;
class loginReq;
class loginResp;
class matchReq;
class matchResp;
class fightMsg;

// ===================================================================

class regReq : public ::google::protobuf::Message {
 public:
  regReq();
  virtual ~regReq();

  regReq(const regReq& from);

  inline regReq& operator=(const regReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const regReq& default_instance();

  void Swap(regReq* other);

  // implements Message ----------------------------------------------

  regReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const regReq& from);
  void MergeFrom(const regReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:msg.regReq)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* deviceid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static regReq* default_instance_;
};
// -------------------------------------------------------------------

class regResp : public ::google::protobuf::Message {
 public:
  regResp();
  virtual ~regResp();

  regResp(const regResp& from);

  inline regResp& operator=(const regResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const regResp& default_instance();

  void Swap(regResp* other);

  // implements Message ----------------------------------------------

  regResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const regResp& from);
  void MergeFrom(const regResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required int32 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:msg.regResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 userid_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static regResp* default_instance_;
};
// -------------------------------------------------------------------

class loginReq : public ::google::protobuf::Message {
 public:
  loginReq();
  virtual ~loginReq();

  loginReq(const loginReq& from);

  inline loginReq& operator=(const loginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginReq& default_instance();

  void Swap(loginReq* other);

  // implements Message ----------------------------------------------

  loginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginReq& from);
  void MergeFrom(const loginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:msg.loginReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginReq* default_instance_;
};
// -------------------------------------------------------------------

class loginResp : public ::google::protobuf::Message {
 public:
  loginResp();
  virtual ~loginResp();

  loginResp(const loginResp& from);

  inline loginResp& operator=(const loginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginResp& default_instance();

  void Swap(loginResp* other);

  // implements Message ----------------------------------------------

  loginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginResp& from);
  void MergeFrom(const loginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string lobbyip = 2;
  inline bool has_lobbyip() const;
  inline void clear_lobbyip();
  static const int kLobbyipFieldNumber = 2;
  inline const ::std::string& lobbyip() const;
  inline void set_lobbyip(const ::std::string& value);
  inline void set_lobbyip(const char* value);
  inline void set_lobbyip(const char* value, size_t size);
  inline ::std::string* mutable_lobbyip();
  inline ::std::string* release_lobbyip();
  inline void set_allocated_lobbyip(::std::string* lobbyip);

  // required int32 lobbyport = 3;
  inline bool has_lobbyport() const;
  inline void clear_lobbyport();
  static const int kLobbyportFieldNumber = 3;
  inline ::google::protobuf::int32 lobbyport() const;
  inline void set_lobbyport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.loginResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_lobbyip();
  inline void clear_has_lobbyip();
  inline void set_has_lobbyport();
  inline void clear_has_lobbyport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* lobbyip_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 lobbyport_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginResp* default_instance_;
};
// -------------------------------------------------------------------

class matchReq : public ::google::protobuf::Message {
 public:
  matchReq();
  virtual ~matchReq();

  matchReq(const matchReq& from);

  inline matchReq& operator=(const matchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const matchReq& default_instance();

  void Swap(matchReq* other);

  // implements Message ----------------------------------------------

  matchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const matchReq& from);
  void MergeFrom(const matchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.matchReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static matchReq* default_instance_;
};
// -------------------------------------------------------------------

class matchResp : public ::google::protobuf::Message {
 public:
  matchResp();
  virtual ~matchResp();

  matchResp(const matchResp& from);

  inline matchResp& operator=(const matchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const matchResp& default_instance();

  void Swap(matchResp* other);

  // implements Message ----------------------------------------------

  matchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const matchResp& from);
  void MergeFrom(const matchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.matchResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static matchResp* default_instance_;
};
// -------------------------------------------------------------------

class fightMsg : public ::google::protobuf::Message {
 public:
  fightMsg();
  virtual ~fightMsg();

  fightMsg(const fightMsg& from);

  inline fightMsg& operator=(const fightMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fightMsg& default_instance();

  void Swap(fightMsg* other);

  // implements Message ----------------------------------------------

  fightMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fightMsg& from);
  void MergeFrom(const fightMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // required int32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.fightMsg)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static fightMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// regReq

// required string deviceid = 1;
inline bool regReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void regReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void regReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void regReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& regReq::deviceid() const {
  // @@protoc_insertion_point(field_get:msg.regReq.deviceid)
  return *deviceid_;
}
inline void regReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:msg.regReq.deviceid)
}
inline void regReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.regReq.deviceid)
}
inline void regReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.regReq.deviceid)
}
inline ::std::string* regReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.regReq.deviceid)
  return deviceid_;
}
inline ::std::string* regReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void regReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.regReq.deviceid)
}

// -------------------------------------------------------------------

// regResp

// required int32 errorCode = 1;
inline bool regResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void regResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void regResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void regResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 regResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.regResp.errorCode)
  return errorcode_;
}
inline void regResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.regResp.errorCode)
}

// required int32 userid = 2;
inline bool regResp::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void regResp::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void regResp::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void regResp::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 regResp::userid() const {
  // @@protoc_insertion_point(field_get:msg.regResp.userid)
  return userid_;
}
inline void regResp::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.regResp.userid)
}

// required string password = 3;
inline bool regResp::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void regResp::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void regResp::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void regResp::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& regResp::password() const {
  // @@protoc_insertion_point(field_get:msg.regResp.password)
  return *password_;
}
inline void regResp::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:msg.regResp.password)
}
inline void regResp::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.regResp.password)
}
inline void regResp::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.regResp.password)
}
inline ::std::string* regResp::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.regResp.password)
  return password_;
}
inline ::std::string* regResp::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void regResp::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.regResp.password)
}

// -------------------------------------------------------------------

// loginReq

// required int32 userid = 1;
inline bool loginReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 loginReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.loginReq.userid)
  return userid_;
}
inline void loginReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.loginReq.userid)
}

// required string password = 2;
inline bool loginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& loginReq::password() const {
  // @@protoc_insertion_point(field_get:msg.loginReq.password)
  return *password_;
}
inline void loginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:msg.loginReq.password)
}
inline void loginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.loginReq.password)
}
inline void loginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.loginReq.password)
}
inline ::std::string* loginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.loginReq.password)
  return password_;
}
inline ::std::string* loginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.loginReq.password)
}

// -------------------------------------------------------------------

// loginResp

// required int32 errorCode = 1;
inline bool loginResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 loginResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.errorCode)
  return errorcode_;
}
inline void loginResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.loginResp.errorCode)
}

// required string lobbyip = 2;
inline bool loginResp::has_lobbyip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginResp::set_has_lobbyip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginResp::clear_has_lobbyip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginResp::clear_lobbyip() {
  if (lobbyip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_->clear();
  }
  clear_has_lobbyip();
}
inline const ::std::string& loginResp::lobbyip() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.lobbyip)
  return *lobbyip_;
}
inline void loginResp::set_lobbyip(const ::std::string& value) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(value);
  // @@protoc_insertion_point(field_set:msg.loginResp.lobbyip)
}
inline void loginResp::set_lobbyip(const char* value) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.loginResp.lobbyip)
}
inline void loginResp::set_lobbyip(const char* value, size_t size) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.loginResp.lobbyip)
}
inline ::std::string* loginResp::mutable_lobbyip() {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.loginResp.lobbyip)
  return lobbyip_;
}
inline ::std::string* loginResp::release_lobbyip() {
  clear_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lobbyip_;
    lobbyip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginResp::set_allocated_lobbyip(::std::string* lobbyip) {
  if (lobbyip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lobbyip_;
  }
  if (lobbyip) {
    set_has_lobbyip();
    lobbyip_ = lobbyip;
  } else {
    clear_has_lobbyip();
    lobbyip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.loginResp.lobbyip)
}

// required int32 lobbyport = 3;
inline bool loginResp::has_lobbyport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void loginResp::set_has_lobbyport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void loginResp::clear_has_lobbyport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void loginResp::clear_lobbyport() {
  lobbyport_ = 0;
  clear_has_lobbyport();
}
inline ::google::protobuf::int32 loginResp::lobbyport() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.lobbyport)
  return lobbyport_;
}
inline void loginResp::set_lobbyport(::google::protobuf::int32 value) {
  set_has_lobbyport();
  lobbyport_ = value;
  // @@protoc_insertion_point(field_set:msg.loginResp.lobbyport)
}

// -------------------------------------------------------------------

// matchReq

// -------------------------------------------------------------------

// matchResp

// required int32 errorCode = 1;
inline bool matchResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void matchResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void matchResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void matchResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 matchResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.errorCode)
  return errorcode_;
}
inline void matchResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.errorCode)
}

// required string ip = 2;
inline bool matchResp::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void matchResp::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void matchResp::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void matchResp::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& matchResp::ip() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.ip)
  return *ip_;
}
inline void matchResp::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:msg.matchResp.ip)
}
inline void matchResp::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.matchResp.ip)
}
inline void matchResp::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.matchResp.ip)
}
inline ::std::string* matchResp::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.matchResp.ip)
  return ip_;
}
inline ::std::string* matchResp::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void matchResp::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.matchResp.ip)
}

// required int32 port = 3;
inline bool matchResp::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void matchResp::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void matchResp::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void matchResp::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 matchResp::port() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.port)
  return port_;
}
inline void matchResp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.port)
}

// -------------------------------------------------------------------

// fightMsg

// required int32 userid = 1;
inline bool fightMsg::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fightMsg::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fightMsg::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fightMsg::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 fightMsg::userid() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.userid)
  return userid_;
}
inline void fightMsg::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.userid)
}

// required int32 roomid = 2;
inline bool fightMsg::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fightMsg::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fightMsg::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fightMsg::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 fightMsg::roomid() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.roomid)
  return roomid_;
}
inline void fightMsg::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.roomid)
}

// required int32 x = 3;
inline bool fightMsg::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fightMsg::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fightMsg::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fightMsg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 fightMsg::x() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.x)
  return x_;
}
inline void fightMsg::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.x)
}

// required int32 y = 4;
inline bool fightMsg::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fightMsg::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fightMsg::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fightMsg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 fightMsg::y() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.y)
  return y_;
}
inline void fightMsg::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.y)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
