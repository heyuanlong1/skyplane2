// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class regReq;
class regResp;
class loginReq;
class loginResp;
class loginLobbyReq;
class loginLobbyResp;
class getRoomAddrReq;
class getRoomAddrResp;
class matchReq;
class matchResp;
class startGameReq;
class startGameResp;
class fightMsg;
class fightMsgResp;

// ===================================================================

class regReq : public ::google::protobuf::Message {
 public:
  regReq();
  virtual ~regReq();

  regReq(const regReq& from);

  inline regReq& operator=(const regReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const regReq& default_instance();

  void Swap(regReq* other);

  // implements Message ----------------------------------------------

  regReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const regReq& from);
  void MergeFrom(const regReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:msg.regReq)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* deviceid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static regReq* default_instance_;
};
// -------------------------------------------------------------------

class regResp : public ::google::protobuf::Message {
 public:
  regResp();
  virtual ~regResp();

  regResp(const regResp& from);

  inline regResp& operator=(const regResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const regResp& default_instance();

  void Swap(regResp* other);

  // implements Message ----------------------------------------------

  regResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const regResp& from);
  void MergeFrom(const regResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required int32 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:msg.regResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 userid_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static regResp* default_instance_;
};
// -------------------------------------------------------------------

class loginReq : public ::google::protobuf::Message {
 public:
  loginReq();
  virtual ~loginReq();

  loginReq(const loginReq& from);

  inline loginReq& operator=(const loginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginReq& default_instance();

  void Swap(loginReq* other);

  // implements Message ----------------------------------------------

  loginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginReq& from);
  void MergeFrom(const loginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:msg.loginReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginReq* default_instance_;
};
// -------------------------------------------------------------------

class loginResp : public ::google::protobuf::Message {
 public:
  loginResp();
  virtual ~loginResp();

  loginResp(const loginResp& from);

  inline loginResp& operator=(const loginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginResp& default_instance();

  void Swap(loginResp* other);

  // implements Message ----------------------------------------------

  loginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginResp& from);
  void MergeFrom(const loginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string lobbyip = 2;
  inline bool has_lobbyip() const;
  inline void clear_lobbyip();
  static const int kLobbyipFieldNumber = 2;
  inline const ::std::string& lobbyip() const;
  inline void set_lobbyip(const ::std::string& value);
  inline void set_lobbyip(const char* value);
  inline void set_lobbyip(const char* value, size_t size);
  inline ::std::string* mutable_lobbyip();
  inline ::std::string* release_lobbyip();
  inline void set_allocated_lobbyip(::std::string* lobbyip);

  // required int32 lobbyport = 3;
  inline bool has_lobbyport() const;
  inline void clear_lobbyport();
  static const int kLobbyportFieldNumber = 3;
  inline ::google::protobuf::int32 lobbyport() const;
  inline void set_lobbyport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.loginResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_lobbyip();
  inline void clear_has_lobbyip();
  inline void set_has_lobbyport();
  inline void clear_has_lobbyport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* lobbyip_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 lobbyport_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginResp* default_instance_;
};
// -------------------------------------------------------------------

class loginLobbyReq : public ::google::protobuf::Message {
 public:
  loginLobbyReq();
  virtual ~loginLobbyReq();

  loginLobbyReq(const loginLobbyReq& from);

  inline loginLobbyReq& operator=(const loginLobbyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginLobbyReq& default_instance();

  void Swap(loginLobbyReq* other);

  // implements Message ----------------------------------------------

  loginLobbyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginLobbyReq& from);
  void MergeFrom(const loginLobbyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:msg.loginLobbyReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginLobbyReq* default_instance_;
};
// -------------------------------------------------------------------

class loginLobbyResp : public ::google::protobuf::Message {
 public:
  loginLobbyResp();
  virtual ~loginLobbyResp();

  loginLobbyResp(const loginLobbyResp& from);

  inline loginLobbyResp& operator=(const loginLobbyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginLobbyResp& default_instance();

  void Swap(loginLobbyResp* other);

  // implements Message ----------------------------------------------

  loginLobbyResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginLobbyResp& from);
  void MergeFrom(const loginLobbyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.loginLobbyResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginLobbyResp* default_instance_;
};
// -------------------------------------------------------------------

class getRoomAddrReq : public ::google::protobuf::Message {
 public:
  getRoomAddrReq();
  virtual ~getRoomAddrReq();

  getRoomAddrReq(const getRoomAddrReq& from);

  inline getRoomAddrReq& operator=(const getRoomAddrReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getRoomAddrReq& default_instance();

  void Swap(getRoomAddrReq* other);

  // implements Message ----------------------------------------------

  getRoomAddrReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getRoomAddrReq& from);
  void MergeFrom(const getRoomAddrReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.getRoomAddrReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static getRoomAddrReq* default_instance_;
};
// -------------------------------------------------------------------

class getRoomAddrResp : public ::google::protobuf::Message {
 public:
  getRoomAddrResp();
  virtual ~getRoomAddrResp();

  getRoomAddrResp(const getRoomAddrResp& from);

  inline getRoomAddrResp& operator=(const getRoomAddrResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getRoomAddrResp& default_instance();

  void Swap(getRoomAddrResp* other);

  // implements Message ----------------------------------------------

  getRoomAddrResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getRoomAddrResp& from);
  void MergeFrom(const getRoomAddrResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string roomip = 2;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomipFieldNumber = 2;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  inline void set_allocated_roomip(::std::string* roomip);

  // required int32 roomport = 3;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomportFieldNumber = 3;
  inline ::google::protobuf::int32 roomport() const;
  inline void set_roomport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.getRoomAddrResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomip_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 roomport_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static getRoomAddrResp* default_instance_;
};
// -------------------------------------------------------------------

class matchReq : public ::google::protobuf::Message {
 public:
  matchReq();
  virtual ~matchReq();

  matchReq(const matchReq& from);

  inline matchReq& operator=(const matchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const matchReq& default_instance();

  void Swap(matchReq* other);

  // implements Message ----------------------------------------------

  matchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const matchReq& from);
  void MergeFrom(const matchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string roomtype = 2;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomtypeFieldNumber = 2;
  inline const ::std::string& roomtype() const;
  inline void set_roomtype(const ::std::string& value);
  inline void set_roomtype(const char* value);
  inline void set_roomtype(const char* value, size_t size);
  inline ::std::string* mutable_roomtype();
  inline ::std::string* release_roomtype();
  inline void set_allocated_roomtype(::std::string* roomtype);

  // optional int32 roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.matchReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomtype_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 roomid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static matchReq* default_instance_;
};
// -------------------------------------------------------------------

class matchResp : public ::google::protobuf::Message {
 public:
  matchResp();
  virtual ~matchResp();

  matchResp(const matchResp& from);

  inline matchResp& operator=(const matchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const matchResp& default_instance();

  void Swap(matchResp* other);

  // implements Message ----------------------------------------------

  matchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const matchResp& from);
  void MergeFrom(const matchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // required string roomtype = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomtypeFieldNumber = 3;
  inline const ::std::string& roomtype() const;
  inline void set_roomtype(const ::std::string& value);
  inline void set_roomtype(const char* value);
  inline void set_roomtype(const char* value, size_t size);
  inline ::std::string* mutable_roomtype();
  inline ::std::string* release_roomtype();
  inline void set_allocated_roomtype(::std::string* roomtype);

  // required int32 owneruserid = 4;
  inline bool has_owneruserid() const;
  inline void clear_owneruserid();
  static const int kOwneruseridFieldNumber = 4;
  inline ::google::protobuf::int32 owneruserid() const;
  inline void set_owneruserid(::google::protobuf::int32 value);

  // required int32 nums = 5;
  inline bool has_nums() const;
  inline void clear_nums();
  static const int kNumsFieldNumber = 5;
  inline ::google::protobuf::int32 nums() const;
  inline void set_nums(::google::protobuf::int32 value);

  // required int32 currnums = 6;
  inline bool has_currnums() const;
  inline void clear_currnums();
  static const int kCurrnumsFieldNumber = 6;
  inline ::google::protobuf::int32 currnums() const;
  inline void set_currnums(::google::protobuf::int32 value);

  // repeated int32 usersid = 7;
  inline int usersid_size() const;
  inline void clear_usersid();
  static const int kUsersidFieldNumber = 7;
  inline ::google::protobuf::int32 usersid(int index) const;
  inline void set_usersid(int index, ::google::protobuf::int32 value);
  inline void add_usersid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      usersid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_usersid();

  // required bool isstart = 8;
  inline bool has_isstart() const;
  inline void clear_isstart();
  static const int kIsstartFieldNumber = 8;
  inline bool isstart() const;
  inline void set_isstart(bool value);

  // @@protoc_insertion_point(class_scope:msg.matchResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_owneruserid();
  inline void clear_has_owneruserid();
  inline void set_has_nums();
  inline void clear_has_nums();
  inline void set_has_currnums();
  inline void clear_has_currnums();
  inline void set_has_isstart();
  inline void clear_has_isstart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 roomid_;
  ::std::string* roomtype_;
  ::google::protobuf::int32 owneruserid_;
  ::google::protobuf::int32 nums_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > usersid_;
  ::google::protobuf::int32 currnums_;
  bool isstart_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static matchResp* default_instance_;
};
// -------------------------------------------------------------------

class startGameReq : public ::google::protobuf::Message {
 public:
  startGameReq();
  virtual ~startGameReq();

  startGameReq(const startGameReq& from);

  inline startGameReq& operator=(const startGameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const startGameReq& default_instance();

  void Swap(startGameReq* other);

  // implements Message ----------------------------------------------

  startGameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const startGameReq& from);
  void MergeFrom(const startGameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.startGameReq)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 roomid_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static startGameReq* default_instance_;
};
// -------------------------------------------------------------------

class startGameResp : public ::google::protobuf::Message {
 public:
  startGameResp();
  virtual ~startGameResp();

  startGameResp(const startGameResp& from);

  inline startGameResp& operator=(const startGameResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const startGameResp& default_instance();

  void Swap(startGameResp* other);

  // implements Message ----------------------------------------------

  startGameResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const startGameResp& from);
  void MergeFrom(const startGameResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // required bool isstart = 3;
  inline bool has_isstart() const;
  inline void clear_isstart();
  static const int kIsstartFieldNumber = 3;
  inline bool isstart() const;
  inline void set_isstart(bool value);

  // @@protoc_insertion_point(class_scope:msg.startGameResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_isstart();
  inline void clear_has_isstart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 roomid_;
  bool isstart_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static startGameResp* default_instance_;
};
// -------------------------------------------------------------------

class fightMsg : public ::google::protobuf::Message {
 public:
  fightMsg();
  virtual ~fightMsg();

  fightMsg(const fightMsg& from);

  inline fightMsg& operator=(const fightMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fightMsg& default_instance();

  void Swap(fightMsg* other);

  // implements Message ----------------------------------------------

  fightMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fightMsg& from);
  void MergeFrom(const fightMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // required string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:msg.fightMsg)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 roomid_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static fightMsg* default_instance_;
};
// -------------------------------------------------------------------

class fightMsgResp : public ::google::protobuf::Message {
 public:
  fightMsgResp();
  virtual ~fightMsgResp();

  fightMsgResp(const fightMsgResp& from);

  inline fightMsgResp& operator=(const fightMsgResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fightMsgResp& default_instance();

  void Swap(fightMsgResp* other);

  // implements Message ----------------------------------------------

  fightMsgResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fightMsgResp& from);
  void MergeFrom(const fightMsgResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.fightMsgResp)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static fightMsgResp* default_instance_;
};
// ===================================================================


// ===================================================================

// regReq

// required string deviceid = 1;
inline bool regReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void regReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void regReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void regReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& regReq::deviceid() const {
  // @@protoc_insertion_point(field_get:msg.regReq.deviceid)
  return *deviceid_;
}
inline void regReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:msg.regReq.deviceid)
}
inline void regReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.regReq.deviceid)
}
inline void regReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.regReq.deviceid)
}
inline ::std::string* regReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.regReq.deviceid)
  return deviceid_;
}
inline ::std::string* regReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void regReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.regReq.deviceid)
}

// -------------------------------------------------------------------

// regResp

// required int32 errorCode = 1;
inline bool regResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void regResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void regResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void regResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 regResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.regResp.errorCode)
  return errorcode_;
}
inline void regResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.regResp.errorCode)
}

// required int32 userid = 2;
inline bool regResp::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void regResp::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void regResp::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void regResp::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 regResp::userid() const {
  // @@protoc_insertion_point(field_get:msg.regResp.userid)
  return userid_;
}
inline void regResp::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.regResp.userid)
}

// required string password = 3;
inline bool regResp::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void regResp::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void regResp::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void regResp::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& regResp::password() const {
  // @@protoc_insertion_point(field_get:msg.regResp.password)
  return *password_;
}
inline void regResp::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:msg.regResp.password)
}
inline void regResp::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.regResp.password)
}
inline void regResp::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.regResp.password)
}
inline ::std::string* regResp::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.regResp.password)
  return password_;
}
inline ::std::string* regResp::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void regResp::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.regResp.password)
}

// -------------------------------------------------------------------

// loginReq

// required int32 userid = 1;
inline bool loginReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 loginReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.loginReq.userid)
  return userid_;
}
inline void loginReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.loginReq.userid)
}

// required string password = 2;
inline bool loginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& loginReq::password() const {
  // @@protoc_insertion_point(field_get:msg.loginReq.password)
  return *password_;
}
inline void loginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:msg.loginReq.password)
}
inline void loginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.loginReq.password)
}
inline void loginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.loginReq.password)
}
inline ::std::string* loginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.loginReq.password)
  return password_;
}
inline ::std::string* loginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.loginReq.password)
}

// -------------------------------------------------------------------

// loginResp

// required int32 errorCode = 1;
inline bool loginResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 loginResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.errorCode)
  return errorcode_;
}
inline void loginResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.loginResp.errorCode)
}

// required string lobbyip = 2;
inline bool loginResp::has_lobbyip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginResp::set_has_lobbyip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginResp::clear_has_lobbyip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginResp::clear_lobbyip() {
  if (lobbyip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_->clear();
  }
  clear_has_lobbyip();
}
inline const ::std::string& loginResp::lobbyip() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.lobbyip)
  return *lobbyip_;
}
inline void loginResp::set_lobbyip(const ::std::string& value) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(value);
  // @@protoc_insertion_point(field_set:msg.loginResp.lobbyip)
}
inline void loginResp::set_lobbyip(const char* value) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.loginResp.lobbyip)
}
inline void loginResp::set_lobbyip(const char* value, size_t size) {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  lobbyip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.loginResp.lobbyip)
}
inline ::std::string* loginResp::mutable_lobbyip() {
  set_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobbyip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.loginResp.lobbyip)
  return lobbyip_;
}
inline ::std::string* loginResp::release_lobbyip() {
  clear_has_lobbyip();
  if (lobbyip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lobbyip_;
    lobbyip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginResp::set_allocated_lobbyip(::std::string* lobbyip) {
  if (lobbyip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lobbyip_;
  }
  if (lobbyip) {
    set_has_lobbyip();
    lobbyip_ = lobbyip;
  } else {
    clear_has_lobbyip();
    lobbyip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.loginResp.lobbyip)
}

// required int32 lobbyport = 3;
inline bool loginResp::has_lobbyport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void loginResp::set_has_lobbyport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void loginResp::clear_has_lobbyport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void loginResp::clear_lobbyport() {
  lobbyport_ = 0;
  clear_has_lobbyport();
}
inline ::google::protobuf::int32 loginResp::lobbyport() const {
  // @@protoc_insertion_point(field_get:msg.loginResp.lobbyport)
  return lobbyport_;
}
inline void loginResp::set_lobbyport(::google::protobuf::int32 value) {
  set_has_lobbyport();
  lobbyport_ = value;
  // @@protoc_insertion_point(field_set:msg.loginResp.lobbyport)
}

// -------------------------------------------------------------------

// loginLobbyReq

// required int32 userid = 1;
inline bool loginLobbyReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginLobbyReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginLobbyReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginLobbyReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 loginLobbyReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.loginLobbyReq.userid)
  return userid_;
}
inline void loginLobbyReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.loginLobbyReq.userid)
}

// required string password = 2;
inline bool loginLobbyReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginLobbyReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginLobbyReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginLobbyReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& loginLobbyReq::password() const {
  // @@protoc_insertion_point(field_get:msg.loginLobbyReq.password)
  return *password_;
}
inline void loginLobbyReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:msg.loginLobbyReq.password)
}
inline void loginLobbyReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.loginLobbyReq.password)
}
inline void loginLobbyReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.loginLobbyReq.password)
}
inline ::std::string* loginLobbyReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.loginLobbyReq.password)
  return password_;
}
inline ::std::string* loginLobbyReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginLobbyReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.loginLobbyReq.password)
}

// -------------------------------------------------------------------

// loginLobbyResp

// required int32 errorCode = 1;
inline bool loginLobbyResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginLobbyResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginLobbyResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginLobbyResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 loginLobbyResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.loginLobbyResp.errorCode)
  return errorcode_;
}
inline void loginLobbyResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.loginLobbyResp.errorCode)
}

// -------------------------------------------------------------------

// getRoomAddrReq

// -------------------------------------------------------------------

// getRoomAddrResp

// required int32 errorCode = 1;
inline bool getRoomAddrResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getRoomAddrResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getRoomAddrResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getRoomAddrResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 getRoomAddrResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.getRoomAddrResp.errorCode)
  return errorcode_;
}
inline void getRoomAddrResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.getRoomAddrResp.errorCode)
}

// required string roomip = 2;
inline bool getRoomAddrResp::has_roomip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getRoomAddrResp::set_has_roomip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getRoomAddrResp::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getRoomAddrResp::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& getRoomAddrResp::roomip() const {
  // @@protoc_insertion_point(field_get:msg.getRoomAddrResp.roomip)
  return *roomip_;
}
inline void getRoomAddrResp::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
  // @@protoc_insertion_point(field_set:msg.getRoomAddrResp.roomip)
}
inline void getRoomAddrResp::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.getRoomAddrResp.roomip)
}
inline void getRoomAddrResp::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.getRoomAddrResp.roomip)
}
inline ::std::string* getRoomAddrResp::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.getRoomAddrResp.roomip)
  return roomip_;
}
inline ::std::string* getRoomAddrResp::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void getRoomAddrResp::set_allocated_roomip(::std::string* roomip) {
  if (roomip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomip_;
  }
  if (roomip) {
    set_has_roomip();
    roomip_ = roomip;
  } else {
    clear_has_roomip();
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.getRoomAddrResp.roomip)
}

// required int32 roomport = 3;
inline bool getRoomAddrResp::has_roomport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getRoomAddrResp::set_has_roomport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getRoomAddrResp::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getRoomAddrResp::clear_roomport() {
  roomport_ = 0;
  clear_has_roomport();
}
inline ::google::protobuf::int32 getRoomAddrResp::roomport() const {
  // @@protoc_insertion_point(field_get:msg.getRoomAddrResp.roomport)
  return roomport_;
}
inline void getRoomAddrResp::set_roomport(::google::protobuf::int32 value) {
  set_has_roomport();
  roomport_ = value;
  // @@protoc_insertion_point(field_set:msg.getRoomAddrResp.roomport)
}

// -------------------------------------------------------------------

// matchReq

// required int32 userid = 1;
inline bool matchReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void matchReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void matchReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void matchReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 matchReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.matchReq.userid)
  return userid_;
}
inline void matchReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.matchReq.userid)
}

// required string roomtype = 2;
inline bool matchReq::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void matchReq::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void matchReq::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void matchReq::clear_roomtype() {
  if (roomtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_->clear();
  }
  clear_has_roomtype();
}
inline const ::std::string& matchReq::roomtype() const {
  // @@protoc_insertion_point(field_get:msg.matchReq.roomtype)
  return *roomtype_;
}
inline void matchReq::set_roomtype(const ::std::string& value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
  // @@protoc_insertion_point(field_set:msg.matchReq.roomtype)
}
inline void matchReq::set_roomtype(const char* value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.matchReq.roomtype)
}
inline void matchReq::set_roomtype(const char* value, size_t size) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.matchReq.roomtype)
}
inline ::std::string* matchReq::mutable_roomtype() {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.matchReq.roomtype)
  return roomtype_;
}
inline ::std::string* matchReq::release_roomtype() {
  clear_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomtype_;
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void matchReq::set_allocated_roomtype(::std::string* roomtype) {
  if (roomtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomtype_;
  }
  if (roomtype) {
    set_has_roomtype();
    roomtype_ = roomtype;
  } else {
    clear_has_roomtype();
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.matchReq.roomtype)
}

// optional int32 roomid = 3;
inline bool matchReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void matchReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void matchReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void matchReq::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 matchReq::roomid() const {
  // @@protoc_insertion_point(field_get:msg.matchReq.roomid)
  return roomid_;
}
inline void matchReq::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.matchReq.roomid)
}

// -------------------------------------------------------------------

// matchResp

// required int32 errorCode = 1;
inline bool matchResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void matchResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void matchResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void matchResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 matchResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.errorCode)
  return errorcode_;
}
inline void matchResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.errorCode)
}

// required int32 roomid = 2;
inline bool matchResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void matchResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void matchResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void matchResp::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 matchResp::roomid() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.roomid)
  return roomid_;
}
inline void matchResp::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.roomid)
}

// required string roomtype = 3;
inline bool matchResp::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void matchResp::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void matchResp::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void matchResp::clear_roomtype() {
  if (roomtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_->clear();
  }
  clear_has_roomtype();
}
inline const ::std::string& matchResp::roomtype() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.roomtype)
  return *roomtype_;
}
inline void matchResp::set_roomtype(const ::std::string& value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
  // @@protoc_insertion_point(field_set:msg.matchResp.roomtype)
}
inline void matchResp::set_roomtype(const char* value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.matchResp.roomtype)
}
inline void matchResp::set_roomtype(const char* value, size_t size) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.matchResp.roomtype)
}
inline ::std::string* matchResp::mutable_roomtype() {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.matchResp.roomtype)
  return roomtype_;
}
inline ::std::string* matchResp::release_roomtype() {
  clear_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomtype_;
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void matchResp::set_allocated_roomtype(::std::string* roomtype) {
  if (roomtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomtype_;
  }
  if (roomtype) {
    set_has_roomtype();
    roomtype_ = roomtype;
  } else {
    clear_has_roomtype();
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.matchResp.roomtype)
}

// required int32 owneruserid = 4;
inline bool matchResp::has_owneruserid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void matchResp::set_has_owneruserid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void matchResp::clear_has_owneruserid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void matchResp::clear_owneruserid() {
  owneruserid_ = 0;
  clear_has_owneruserid();
}
inline ::google::protobuf::int32 matchResp::owneruserid() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.owneruserid)
  return owneruserid_;
}
inline void matchResp::set_owneruserid(::google::protobuf::int32 value) {
  set_has_owneruserid();
  owneruserid_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.owneruserid)
}

// required int32 nums = 5;
inline bool matchResp::has_nums() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void matchResp::set_has_nums() {
  _has_bits_[0] |= 0x00000010u;
}
inline void matchResp::clear_has_nums() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void matchResp::clear_nums() {
  nums_ = 0;
  clear_has_nums();
}
inline ::google::protobuf::int32 matchResp::nums() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.nums)
  return nums_;
}
inline void matchResp::set_nums(::google::protobuf::int32 value) {
  set_has_nums();
  nums_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.nums)
}

// required int32 currnums = 6;
inline bool matchResp::has_currnums() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void matchResp::set_has_currnums() {
  _has_bits_[0] |= 0x00000020u;
}
inline void matchResp::clear_has_currnums() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void matchResp::clear_currnums() {
  currnums_ = 0;
  clear_has_currnums();
}
inline ::google::protobuf::int32 matchResp::currnums() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.currnums)
  return currnums_;
}
inline void matchResp::set_currnums(::google::protobuf::int32 value) {
  set_has_currnums();
  currnums_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.currnums)
}

// repeated int32 usersid = 7;
inline int matchResp::usersid_size() const {
  return usersid_.size();
}
inline void matchResp::clear_usersid() {
  usersid_.Clear();
}
inline ::google::protobuf::int32 matchResp::usersid(int index) const {
  // @@protoc_insertion_point(field_get:msg.matchResp.usersid)
  return usersid_.Get(index);
}
inline void matchResp::set_usersid(int index, ::google::protobuf::int32 value) {
  usersid_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.matchResp.usersid)
}
inline void matchResp::add_usersid(::google::protobuf::int32 value) {
  usersid_.Add(value);
  // @@protoc_insertion_point(field_add:msg.matchResp.usersid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
matchResp::usersid() const {
  // @@protoc_insertion_point(field_list:msg.matchResp.usersid)
  return usersid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
matchResp::mutable_usersid() {
  // @@protoc_insertion_point(field_mutable_list:msg.matchResp.usersid)
  return &usersid_;
}

// required bool isstart = 8;
inline bool matchResp::has_isstart() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void matchResp::set_has_isstart() {
  _has_bits_[0] |= 0x00000080u;
}
inline void matchResp::clear_has_isstart() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void matchResp::clear_isstart() {
  isstart_ = false;
  clear_has_isstart();
}
inline bool matchResp::isstart() const {
  // @@protoc_insertion_point(field_get:msg.matchResp.isstart)
  return isstart_;
}
inline void matchResp::set_isstart(bool value) {
  set_has_isstart();
  isstart_ = value;
  // @@protoc_insertion_point(field_set:msg.matchResp.isstart)
}

// -------------------------------------------------------------------

// startGameReq

// required int32 roomid = 1;
inline bool startGameReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void startGameReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void startGameReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void startGameReq::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 startGameReq::roomid() const {
  // @@protoc_insertion_point(field_get:msg.startGameReq.roomid)
  return roomid_;
}
inline void startGameReq::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.startGameReq.roomid)
}

// -------------------------------------------------------------------

// startGameResp

// required int32 errorCode = 1;
inline bool startGameResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void startGameResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void startGameResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void startGameResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 startGameResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.startGameResp.errorCode)
  return errorcode_;
}
inline void startGameResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.startGameResp.errorCode)
}

// required int32 roomid = 2;
inline bool startGameResp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void startGameResp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void startGameResp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void startGameResp::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 startGameResp::roomid() const {
  // @@protoc_insertion_point(field_get:msg.startGameResp.roomid)
  return roomid_;
}
inline void startGameResp::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.startGameResp.roomid)
}

// required bool isstart = 3;
inline bool startGameResp::has_isstart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void startGameResp::set_has_isstart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void startGameResp::clear_has_isstart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void startGameResp::clear_isstart() {
  isstart_ = false;
  clear_has_isstart();
}
inline bool startGameResp::isstart() const {
  // @@protoc_insertion_point(field_get:msg.startGameResp.isstart)
  return isstart_;
}
inline void startGameResp::set_isstart(bool value) {
  set_has_isstart();
  isstart_ = value;
  // @@protoc_insertion_point(field_set:msg.startGameResp.isstart)
}

// -------------------------------------------------------------------

// fightMsg

// required int32 userid = 1;
inline bool fightMsg::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fightMsg::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fightMsg::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fightMsg::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 fightMsg::userid() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.userid)
  return userid_;
}
inline void fightMsg::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.userid)
}

// required int32 roomid = 2;
inline bool fightMsg::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fightMsg::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fightMsg::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fightMsg::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 fightMsg::roomid() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.roomid)
  return roomid_;
}
inline void fightMsg::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsg.roomid)
}

// required string msg = 3;
inline bool fightMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fightMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fightMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fightMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& fightMsg::msg() const {
  // @@protoc_insertion_point(field_get:msg.fightMsg.msg)
  return *msg_;
}
inline void fightMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:msg.fightMsg.msg)
}
inline void fightMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.fightMsg.msg)
}
inline void fightMsg::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.fightMsg.msg)
}
inline ::std::string* fightMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:msg.fightMsg.msg)
  return msg_;
}
inline ::std::string* fightMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void fightMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.fightMsg.msg)
}

// -------------------------------------------------------------------

// fightMsgResp

// required int32 errorCode = 1;
inline bool fightMsgResp::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fightMsgResp::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fightMsgResp::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fightMsgResp::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 fightMsgResp::errorcode() const {
  // @@protoc_insertion_point(field_get:msg.fightMsgResp.errorCode)
  return errorcode_;
}
inline void fightMsgResp::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:msg.fightMsgResp.errorCode)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
